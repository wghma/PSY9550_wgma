prior <- rep( 1 , 20 )
# compute likelihood at each value in grid
likelihood <- dbinom( 6 , size=9 , prob=p_grid )
unstd.posterior <- likelihood * prior
posterior <- unstd.posterior / sum(unstd.posterior)
curve(dbinom(6, size = 10, prob = 0.4),
from = 0,
to = 1,
n = 500,
main = "Probability density for the binomial distribution")}
curve(dbinom(6, size = 10, prob = 0.4),
from = 0,
to = 1,
n = 500,
main = "Probability density for the binomial distribution")
curve(dbinom(x, size = 10, prob = 0.4),
from = 0,
to = 1,
n = 500,
main = "Probability density for the binomial distribution")
curve(dbinom(x, size = 10, prob = 0.4),
from = 0,
to = 1,
n = 20,
main = "Probability density for the binomial distribution")
dbinom(1, size = 10, prob = 0.4)
curve(dbinom(x, size = 10, prob = 0.4),
from = -1,
to = 1,
n = 20,
main = "Probability density for the binomial distribution")
curve(dbinom(x, size = 10, prob = 0.4),
from = 0,
to = 1,
n = 20,
main = "Probability density for the binomial distribution")
dbinom(1:20, size = 10, prob = 0.4)
dbinom(1:10, size = 10, prob = 0.4)
curve(dbinom(x, size = 10, prob = 0.4),
from = 0,
to = 1,
n = 40,
main = "Probability density for the binomial distribution")
curve(dbinom(x, size = 10, prob = 0.4),
from = 0,
to = 40,
n = 40,
main = "Probability density for the binomial distribution")
curve(dbinom(x, size = 10, prob = 0.4),
from = 0,
to = 40,
n = 30,
main = "Probability density for the binomial distribution")
curve(dbinom(x, size = 40, prob = 0.4),
from = 0,
to = 40,
n = 30,
main = "Probability density for the binomial distribution")
?curve
plot(dbinom(1:10, size = 10, prob = 0.4))
plot(dbinom(1:10, size = 100, prob = 0.4))
plot(dbinom(1:100, size = 100, prob = 0.4))
plot(dbinom(1:100, size = 100, prob = 0.3))
plot(dbinom(1:30, size = 100, prob = 0.3))
n <- 100
plot(dbinom(1:n, size = n, prob = 0.3))
# dette plottet ser bedre ut
n <- 50
plot(dbinom(1:n, size = n, prob = 0.3))
# dette plottet ser bedre ut
n <- 100
plot(dbinom(1:n, size = n, prob = 0.3))
dbinom(5, 10, prob = 0.2)
dbinom(6, 10, prob = 0.2)
dbinom(30, n, prob = 0.3)
max(dbinom(1:n, size = n, prob = 0.3))
#define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior, p for water
prior <- rep( 1 , 20 )
# compute likelihood at each value in grid
draws <- 100
likelihood <- dbinom( draws*p_grid , size=draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
draws*p_grid
p_grid %>%
writeClipboard()
library(tidyverse)
library(tidyverse)
library(clipr)
p_grid %>% write_clip()
#define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior, p for water
prior <- rep( 1 , 20 )
# compute likelihood at each value in grid
n_draws <- 3
n_water <- 3
likelihood <- dbinom(n_water , size=n_draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
plot( p_grid , posterior ,
type="b" ,
xlab="probability of water" ,
ylab="posterior probability" )
mtext( "20 points" )
define grid
#define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior, p for water
prior <- rep( 1 , 20 )
# compute likelihood at each value in grid
n_draws <- 4
n_water <- 3
likelihood <- dbinom(n_water , size=n_draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
plot( p_grid , posterior ,
type="b" ,
xlab="probability of water" ,
ylab="posterior probability" )
mtext( "20 points. Data: WWWL" )
#define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior, p for water
prior <- rep( 3 , 20 )
# compute likelihood at each value in grid
n_draws <- 4
n_water <- 3
likelihood <- dbinom(n_water , size=n_draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
plot( p_grid , posterior ,
type="b" ,
xlab="probability of water" ,
ylab="posterior probability" )
mtext( "20 points. Data: WWWL" )
#define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior, p for water
prior <- rep( 1 , 20 )
# compute likelihood at each value in grid
n_draws <- 7
n_water <- 5
likelihood <- dbinom(n_water , size=n_draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
plot( p_grid , posterior ,
type="b" ,
xlab="probability of water" ,
ylab="posterior probability" )
mtext( "20 points. Data: LWWLWWW" )
# define prior, p for water
prior <- ifelse(p_grid> 0.5, 0, 1)
#define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior, p for water
prior <- ifelse(p_grid> 0.5, 0, 1)
# define prior, p for water
prior <- ifelse(p_grid< 0.5, 0, 1)
# define prior, p for water
prior <- p_grid[p_grid>0.5]
# define prior, p for water
prior <- p_grid[p_grid>0.5 == 1]
# define prior, p for water
prior <- p_grid[p_grid>0.5 = 1]
# define prior, p for water
prior <- [p_grid>0.5 = 1]
# define prior, p for water
prior <- [p_grid>0.5]
# define prior, p for water
prior <- p_grid>0.5
# define prior, p for water
prior <- p_grid>0.5*1
# define prior, p for water
prior <- p_grid %>%
mutate(p_grid = ifelse(p_grid > 0.5, 1, 0))
# define prior, p for water
prior <- 1*(p_grid>= 0.5)
prior
#define grid
p_grid <- c(0.3, 1)
# define prior, p for land
prior <- rep(1,2)
# compute likelihood at each value in grid
n_draws <- 1
n_land <- 1
likelihood <- dbinom(n_land , size=n_draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
#define grid
p_grid <- c(0.3, 1)
# define prior, p for land
prior <- rep(1,2)
# compute likelihood at each value in grid
n_draws <- 1
n_land <- 1
likelihood <- dbinom(n_land , size=n_draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
plot( p_grid , posterior ,
type="b" ,
xlab="probability of land" ,
ylab="posterior probability" )
mtext( "2 points. Data: L." )
#define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior, p for land
prior <- 1*(p_grid> 0.7)
# compute likelihood at each value in grid
n_draws <- 1
n_land <- 1
likelihood <- dbinom(n_land , size=n_draws , prob=p_grid ) # max(dinom|p,n) is at x = n*p
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
plot( p_grid , posterior ,
type="b" ,
xlab="probability of land" ,
ylab="posterior probability" )
mtext( "20 points. Data: L." )
1.372
1.3/2
0.3*0.5
0.15/0.62
4/13
0.5*0.5*0.3
library(tidyverse)
library(clipr)
tibble(p_grid = seq(from = 0, to = 1, length.out = 20),
prior = rep(1, times = 20))
tibble(p_grid = seq(from = 0, to = 1, length.out = 20),
prior = rep(1, times = 20)) %>%
mutate(likelihood_1 = dbinom(3, size = 3, prob = p_grid),
likelihood_2 = dbinom(3, size = 4, prob = p_grid),
likelihood_3 = dbinom(5, size = 7, prob = p_grid),
across(starts_with("likelihood"), ~ .x * prior),
across(starts_with("likelihood"), ~ .x / sum(.x)))
tibble(p_grid = seq(from = 0, to = 1, length.out = 20),
prior = rep(1, times = 20)) %>%
mutate(likelihood_1 = dbinom(3, size = 3, prob = p_grid),
likelihood_2 = dbinom(3, size = 4, prob = p_grid),
likelihood_3 = dbinom(5, size = 7, prob = p_grid),
across(starts_with("likelihood"), ~ .x * prior),
across(starts_with("likelihood"), ~ .x / sum(.x))) %>%
pivot_longer(cols = starts_with("likelihood"), names_to = "pattern",
values_to = "posterior") %>%
separate(pattern, c(NA, "pattern"), sep = "_", convert = TRUE)
tibble(p_grid = seq(from = 0, to = 1, length.out = 20),
prior = rep(1, times = 20)) %>%
mutate(likelihood_1 = dbinom(3, size = 3, prob = p_grid),
likelihood_2 = dbinom(3, size = 4, prob = p_grid),
likelihood_3 = dbinom(5, size = 7, prob = p_grid),
across(starts_with("likelihood"), ~ .x * prior),
across(starts_with("likelihood"), ~ .x / sum(.x))) %>%
pivot_longer(cols = starts_with("likelihood"), names_to = "pattern",
values_to = "posterior")
dist <- tibble(p_grid = seq(from = 0, to = 1, length.out = 20),
prior = rep(1, times = 20)) %>%
mutate(likelihood_1 = dbinom(3, size = 3, prob = p_grid),
likelihood_2 = dbinom(3, size = 4, prob = p_grid),
likelihood_3 = dbinom(5, size = 7, prob = p_grid),
across(starts_with("likelihood"), ~ .x * prior),
across(starts_with("likelihood"), ~ .x / sum(.x))) %>%
pivot_longer(cols = starts_with("likelihood"), names_to = "pattern",
values_to = "posterior") %>%
# separate(pattern, c(NA, "pattern"), sep = "_", convert = TRUE) %>%
mutate(obs = case_when(str_detect(pattern, "1") ~ "W, W, W",
str_detect(pattern, "2")  ~ "W, W, W, L",
str_detect(pattern, "3")  ~ "L, W, W, L, W, W, W"))
View(dist)
ggplot(dist, aes(x = p_grid, y = posterior)) +
facet_wrap(vars(fct_inorder(obs)), nrow = 1) +
geom_line() +
geom_point() +
labs(x = "Proportion Water (p)", y = "Posterior Density")
dist <- tibble(p_grid = seq(from = 0, to = 1, length.out = 20)) %>%
mutate(prior = case_when(p_grid < 0.5 ~ 0L,
TRUE ~ 1L),
likelihood_1 = dbinom(3, size = 3, prob = p_grid),
likelihood_2 = dbinom(3, size = 4, prob = p_grid),
likelihood_3 = dbinom(5, size = 7, prob = p_grid),
across(starts_with("likelihood"), ~ .x * prior),
across(starts_with("likelihood"), ~ .x / sum(.x))) %>%
pivot_longer(cols = starts_with("likelihood"), names_to = "pattern",
values_to = "posterior") %>%
separate(pattern, c(NA, "pattern"), sep = "_", convert = TRUE) %>%
mutate(obs = case_when(pattern == 1L ~ "W, W, W",
pattern == 2L ~ "W, W, W, L",
pattern == 3L ~ "L, W, W, L, W, W, W"))
ggplot(dist, aes(x = p_grid, y = posterior)) +
facet_wrap(vars(fct_inorder(obs)), nrow = 1) +
geom_line() +
geom_point() +
labs(x = "Proportion Water (p)", y = "Posterior Density", title = "Boolean prior divided at p = 0.5")
0.3*0.5+0.5
```{r}
card_bb_likelihood <- 2  # number of possibilities where side = 1 black
card_bw_likelihood <- 1
card_ww_likelihood <- 0
likelihood <- c(card_bb_likelihood, card_bw_likelihood, card_ww_likelihood)
prior <- c(1, 1, 1)
posterior <- likelihood * prior
posterior <- posterior / sum(posterior)
card_bb_likelihood <- 2 * 3
card_wb_likelihood <- 1 * 2
card_ww_likelihood <- 0
likelihood <- c(card_bb_likelihood, card_wb_likelihood, card_ww_likelihood)
prior <- c(1,1,1)
posterior <- prior * likelihood
posterior <- posterior / sum(posterior)
posterior[1]
4/6
(2/3)*(2/3)
```{r}
p_grid <- seq(from = 0, to = 1, length.out = 1000)
prior <- rep(1, 1000)
likelihood <- dbinom(6, size = 9, prob = p_grid)
posterior <- likelihood * prior
posterior <- posterior / sum(posterior)
set.seed(100)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
mean(samples < 0.2)
uessed expected proportion
prob.success.prior = .2 # guessed expected proportion
n.prior.obs = 3 # Here, sample size just refers to the number of fellow students you know well enough to guess how they would do.
a.prior = prob.success.prior*n.prior.obs # number of successes
b.prior = (1-prob.success.prior)*n.prior.obs # number of fails
N.sim = 5000
info_prior = rbeta(N.sim, a.prior, b.prior)
info_prior[1:30] # a beta distribution. Prior. P(x), as in P(x|data) = posterior = P(data|x)*P(x)/P(data)
hist(info_prior,
breaks = seq(0,1,.05),
col = "blue",
main = "Information before seeing data",
xlab = "Success probability")
e of 13
n.obs = 13 # number of responses
successes = 4 # number of participants with a perfect score
prob.success = successes / n.obs
simulated.successes =
rbinom(1, n.obs, info_prior[1])
simulated.successes
simulated.successes =
rbinom(1, n.obs, info_prior[1])
simulated.successes
# we try again, but make 250 draws with shifting priors (from prior beta distribution)
simulated.successes =
rbinom(250,n.obs,info_prior[1:250])
good.thetas =
info_prior[which(simulated.successes == successes)] %>%
round(digits = 2)
library(tidyverse)
```{r, warning=F}
library(tidyverse)
prob.success.prior = .2 # guessed expected proportion
# we try again, but make 250 draws with shifting priors (from prior beta distribution)
simulated.successes =
rbinom(250,n.obs,info_prior[1:250])
good.thetas =
info_prior[which(simulated.successes == successes)] %>%
round(digits = 2)
round(good.thetas, digits = 3)
filtered.samples =
data.frame(prior.value = info_prior) %>%
rowwise() %>%
mutate(simulated.successes = rbinom(1,n.obs,prior.value),
keep = ifelse(simulated.successes == successes,"keep","reject"))
# rowwise and mutate are dplyr functions
filtered.samples$keep =
factor(filtered.samples$keep,
levels = c("reject","keep"))
filtered.samples %>%
histStack(prior.value~keep,.,
breaks = seq(0,1,.05),
col = c("blue","purple"),
xlab = "Success probability",
main = "Filter prior information",
legend.pos = "topright")
install.packages("plotrix")
library(plotrix) #histstack
filtered.samples %>%
histStack(prior.value~keep,.,
breaks = seq(0,1,.05),
col = c("blue","purple"),
xlab = "Success probability",
main = "Filter prior information",
legend.pos = "topright")
fn =
paste(a.prior,b.prior,n.obs,prob.success,"mp4", sep = ".")
my_histStack = function(dt, ylim = NULL) {
dt %>%
histStack(prior.value~keep,.,
ylim = ylim, xlim = c(0,1),
breaks = seq(0,1,.05),
col = c("blue","purple"),
xlab = "Success probability",
main = "Filter prior information with data",
legend.pos = "topright", border = NA,
cex = 1.75, cex.axis = 1.75, cex.lab = 1.75, cex.main = 2)
}
ylim = c(0,
hist(filtered.samples$prior.value,
breaks = seq(0,1,.05), plot = FALSE)$count %>% max())
if(!file.exists(fn)) {
library(plotrix)
kk = round(seq(1,nrow(filtered.samples), length.out = 500))
for (i in 1:length(kk)) {
png(paste0("anim/",sprintf("%03.f", i),".png"),
width = 700, height = 700)
par(mar = c(5.1, 6.1, 4.1, 1.1))
my_histStack(filtered.samples[1:kk[i],], ylim)
dev.off()
}
imgs = list.files("anim", full.names = T)
library(av)
av::av_encode_video(imgs, framerate = 30,
output = fn)
}
set.seed(123)
# draw the background
draw_pie()
draw_ellipse()
?draw_pie
install.packages("cape")
library(cape)
set.seed(123)
draw_ellipse()
install.packages("cursr")
library(cursr)
# draw the background
draw_pie()
draw_ellipse()
# draw the background
cape::draw_pie()
library(cape)
library(cursr)
N = 365
is.winter = vector(length = N) # vector to count winter days
is.snow = vector(length = N) # vector to count snow days
for (k in 1:N) {
# generate random point with custom function
xy = rpoint_in_circle()
# check if it is a snow day, i.e. in ellipse, with custom function
is.snow[k] = in_ellipse(xy,h.e,k.e,a.e,b.e,e.rot)
# check if it is a winter day
is.winter[k] = xy[1] > 0 & xy[2] < 0
# plot points
points(xy[1],xy[2],
pch = ifelse(is.snow[k] == T,8,21), cex = .75,
bg = ifelse(is.winter[k] == T,"blue","red"),
col = ifelse(is.winter[k] == T,"blue","red"))
}
library(cape)
library(cape)
library(cursr)
library(cape)
library(cursr)
```{r}
set.seed(123)
# draw the background
cape::draw_pie()
# draw the background
draw_pie()
library(cursr)
library(cape)
set.seed(123)
# draw the background
draw_pie()
draw_ellipse()
48/248
library(cursr)
library(cape)
library(coda)
library(mvtnorm)
library(devtools)
library(loo)
library(dagitty)
library(magrittr)
# draw the background
draw_pie()
draw_ellipse()
set.seed(123)
par(mar = c(0,0,0,0))
cols = c("violet","red","orange","green4")
pie(c(1,9,89,901), labels = "", border = NA, col = cols )
legend("topleft",
bty = "n",
fill = cols,
legend = c(
"False negatitve",
"True positive",
"False positive",
"True Negative"
))
pie(c(1,9,89,901), labels = "", border = NA, col = cols )
p_grid = seq(0,1,by = .05)
prior = dbeta(p_grid,2,1)
plot(p_grid, prior, type = "h", col = "blue",
ylab = "density", main = "Prior")
